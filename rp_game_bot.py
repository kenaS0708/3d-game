import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackContext, CallbackQueryHandler
import json
import random
from datetime import datetime, timedelta

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Bot token (replace with your bot token)
TOKEN = "7260525635:AAF63mWkBTYl-p0D01-BfGlSaCsJamT-wi0"

# Store user data
user_data = {}
try:
    with open('user_data.json', 'r') as f:
        user_data = json.load(f)
except FileNotFoundError:
    pass

# Available jobs
jobs = {
    'like_post': {
        'name': '–ü–æ—Å—Ç–∞–≤–∏—Ç—å –ª–∞–π–∫',
        'description': '–ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –∏ –ø–æ—Å—Ç–∞–≤—å—Ç–µ –ª–∞–π–∫',
        'url': 'https://t.me/your_channel/post',
        'xp': 10,
        'cooldown': 3600  # cooldown in seconds (1 hour)
    },
    'share_post': {
        'name': '–ü–æ–¥–µ–ª–∏—Ç—å—Å—è –ø–æ—Å—Ç–æ–º',
        'description': '–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å –ø–æ—Å—Ç–æ–º —Å –¥—Ä—É–∑—å—è–º–∏',
        'url': 'https://t.me/share/url?url=your_share_link',
        'xp': 15,
        'cooldown': 7200  # 2 hours
    },
    'subscribe': {
        'name': '–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª',
        'description': '–ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª',
        'url': 'https://t.me/your_channel',
        'xp': 20,
        'cooldown': 86400  # 24 hours
    }
}

def save_user_data():
    with open('user_data.json', 'w') as f:
        json.dump(user_data, f)

async def start(update: Update, context: CallbackContext):
    user_id = str(update.effective_user.id)
    if user_id not in user_data:
        user_data[user_id] = {
            'xp': 0,
            'completed_jobs': {},
            'rank': '–ù–æ–≤–∏—á–æ–∫'
        }
        save_user_data()
    
    await update.message.reply_text(
        '–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã –≤ RP –∏–≥—Ä–µ. –ò—Å–ø–æ–ª—å–∑—É–π /job –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–∞–±–æ—Ç.'
    )

def get_rank(xp):
    if xp < 100:
        return '–ù–æ–≤–∏—á–æ–∫'
    elif xp < 300:
        return '–û–ø—ã—Ç–Ω—ã–π'
    elif xp < 600:
        return '–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª'
    else:
        return '–ú–∞—Å—Ç–µ—Ä'

async def job(update: Update, context: CallbackContext):
    keyboard = []
    for job_id, job_info in jobs.items():
        keyboard.append([InlineKeyboardButton(
            job_info['name'], 
            callback_data=f'job_{job_id}'
        )])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        '–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–±–æ—Ç—É:',
        reply_markup=reply_markup
    )

async def button_callback(update: Update, context: CallbackContext):
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    if user_id not in user_data:
        user_data[user_id] = {
            'xp': 0,
            'completed_jobs': {},
            'rank': '–ù–æ–≤–∏—á–æ–∫'
        }
    
    job_id = query.data.replace('job_', '')
    job_info = jobs[job_id]
    
    # Check cooldown
    now = datetime.now().timestamp()
    if job_id in user_data[user_id].get('completed_jobs', {}):
        last_completion = user_data[user_id]['completed_jobs'][job_id]
        if now - last_completion < job_info['cooldown']:
            time_left = int(job_info['cooldown'] - (now - last_completion))
            await query.answer(
                f'–ü–æ–¥–æ–∂–¥–∏—Ç–µ {time_left // 3600} —á {(time_left % 3600) // 60} –º–∏–Ω –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω—ã–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º',
                show_alert=True
            )
            return
    
    # Add XP and update completion time
    user_data[user_id]['xp'] += job_info['xp']
    user_data[user_id]['completed_jobs'][job_id] = now
    
    # Update rank
    new_rank = get_rank(user_data[user_id]['xp'])
    user_data[user_id]['rank'] = new_rank
    
    save_user_data()
    
    await query.answer()
    await query.message.reply_text(
        f"‚ú® –ó–∞–¥–∞–Ω–∏–µ: {job_info['name']}\n"
        f"üìù {job_info['description']}\n"
        f"üîó –°—Å—ã–ª–∫–∞: {job_info['url']}\n"
        f"üíé –ù–∞–≥—Ä–∞–¥–∞: +{job_info['xp']} XP\n\n"
        f"–í–∞—à —Ç–µ–∫—É—â–∏–π —Ä–∞–Ω–≥: {new_rank}\n"
        f"–í—Å–µ–≥–æ XP: {user_data[user_id]['xp']}"
    )

async def stats(update: Update, context: CallbackContext):
    user_id = str(update.effective_user.id)
    if user_id not in user_data:
        await update.message.reply_text('–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏. –ù–∞—á–Ω–∏—Ç–µ –≤—ã–ø–æ–ª–Ω—è—Ç—å –∑–∞–¥–∞–Ω–∏—è!')
        return
    
    user_stats = user_data[user_id]
    await update.message.reply_text(
        f"üìä –í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
        f"–†–∞–Ω–≥: {user_stats['rank']}\n"
        f"XP: {user_stats['xp']}\n"
        f"–í—ã–ø–æ–ª–Ω–µ–Ω–æ –∑–∞–¥–∞–Ω–∏–π: {len(user_stats.get('completed_jobs', {}))}"
    )

def main():
    application = Application.builder().token(TOKEN).build()
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("job", job))
    application.add_handler(CommandHandler("stats", stats))
    application.add_handler(CallbackQueryHandler(button_callback))
    
    application.run_polling()

if __name__ == '__main__':
    main()
